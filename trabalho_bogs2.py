# -*- coding: utf-8 -*-
"""trabalho_bogs2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jTzUOrNGa3-PBUO5YVm-zKvjWJdLF_dp
"""

# ALUNOS
# Antonio Neves de Brito Junior 2236605
# Christoffer Nogueira Spring 2241471
import sys
import timeit
import numpy as np
import math
import cv2

#
# finish saving in separable or make it so it doesnt save
#
# ===============================================================================


INPUT_IMAGE = 'a01 - Original.bmp'

# Parâmetros:
WINDOW_ROWS = 11
WINDOW_COLS = 15

# ===============================================================================

# Algoritmo “ingênuo”.


def ingenuo(img):
    rows, cols, channels = img.shape
    img_ingenuo = img.copy()

    mod_r = 1
    if WINDOW_ROWS % 2 == 0:
        mod_r = 0
    mod_c = 1
    if WINDOW_COLS % 2 == 0:
        mod_c = 0

    for channel in range(channels):
        for row in range(int(math.floor(WINDOW_ROWS / 2)), int(math.floor(rows - (WINDOW_ROWS / 2)))):
            for col in range(int(math.floor(WINDOW_COLS / 2)), int(math.floor(cols - (WINDOW_COLS / 2)))):
                sum = 0.0
                for y in range(int(math.ceil(WINDOW_ROWS / -2)), int(math.floor(WINDOW_ROWS / 2))):
                    for x in range(int(math.ceil(WINDOW_COLS / -2)), int(math.floor(WINDOW_COLS / 2))):
                        sum = sum + img[row + y, col + x, channel]
                med = sum / ((WINDOW_ROWS - mod_r) * (WINDOW_COLS - mod_c))
                img_ingenuo[row, col, channel] = med

    return img_ingenuo


def ingenuo_salvando(img):
    rows, cols, channels = img.shape
    img_ingenuo = img.copy()
    wnd_cols = int(math.floor(WINDOW_COLS / 2))
    wnd_rows = int(math.floor(WINDOW_ROWS / 2))

    for channel in range(channels):
        for row in range(int(math.floor(WINDOW_ROWS / 2)), int(math.floor(rows - (WINDOW_ROWS / 2)))):
            sum = 0.0
            for col in range(int(math.floor(WINDOW_COLS / 2)), int(math.floor(cols - (WINDOW_COLS / 2)))):
                if col == int(math.floor(WINDOW_COLS / 2)):
                    for y in range(-wnd_rows, wnd_rows):
                        for x in range(-wnd_cols, wnd_cols):
                            sum = sum + img[row + y, col + x, channel]

                else:
                    for i in range(-wnd_rows, wnd_rows):
                        sum = sum + img[row + i, col + wnd_cols,
                                        channel] - img[row + i, col - wnd_cols, channel]

                med = sum / ((WINDOW_ROWS - 1) * (WINDOW_COLS - 1))
                img_ingenuo[row, col, channel] = med

    return img_ingenuo

# Filtro separável (com ou sem aproveitar as somas anteriores).


def sep_first(img, img_separavel):
    rows, cols, channels = img.shape
    wnd_cols = int(math.floor(WINDOW_COLS / 2))
    wnd_rows = int(math.floor(WINDOW_ROWS / 2))

    mod_c = 1
    if WINDOW_COLS % 2 == 0:
        mod_c = 0

    for channel in range(channels):
        for row in range(wnd_rows, rows - wnd_rows):
            for col in range(wnd_cols, cols - wnd_cols):
                med = 0.0
                for x in range(-wnd_cols, wnd_cols):
                    med = med + img[row, col + x, channel]
                med = med / (WINDOW_COLS - mod_c)

                img_separavel[row, col, channel] = med

    return img_separavel


def sep_second(img, img_separavel):
    rows, cols, channels = img.shape
    wnd_cols = int(math.floor(WINDOW_COLS / 2))
    wnd_rows = int(math.floor(WINDOW_ROWS / 2))

    mod_r = 1
    if WINDOW_ROWS % 2 == 0:
        mod_r = 0

    for channel in range(channels):
        for col in range(wnd_cols, cols - wnd_cols):
            for row in range(wnd_rows, rows - wnd_rows):
                med = 0.0
                for y in range(-wnd_rows, wnd_rows):
                    med = med + img[row + y, col, channel]
                med = med / (WINDOW_ROWS - mod_r)

                img_separavel[row, col, channel] = med

    return img_separavel


def separavel(img):
    img_separavel_first = img.copy()
    img_separavel_first = sep_first(img, img_separavel_first)

    img_separavel_second = img_separavel_first.copy()
    img_separavel_second = sep_second(
        img_separavel_first, img_separavel_second)

    return img_separavel_second

# Algoritmo com imagens integrais.


def integralize(img):
    rows, cols, channels = img.shape

    for channel in range(channels):

        for row in range(rows):
            sum = 0
            for col in range(cols):
                sum += img[row, col, channel]
                img[row, col, channel] = sum
                if row > 0:
                    img[row, col, channel] += img[row - 1, col, channel]

    return img


def integral(img):
    img_integral = img.copy()
    img_final = img.copy()
    img_integral = integralize(img_integral)
    rows, cols, channels = img.shape

    for channel in range(channels):

        for row in range(rows):
            for col in range(cols):
                # menor que janela:
                if row <= int(math.floor(WINDOW_ROWS / 2)):
                    top = row
                else:
                    top = int(math.floor(WINDOW_ROWS / 2))

                if col <= int(math.floor(WINDOW_COLS / 2)):
                    left = col
                else:
                    left = int(math.floor(WINDOW_COLS / 2))

                if row >= rows - int(math.floor(WINDOW_ROWS / 2)):
                    bottom = rows - row - 1
                else:
                    bottom = int(math.floor(WINDOW_ROWS / 2))

                if col >= cols - int(math.floor(WINDOW_COLS / 2)):
                    right = cols - col - 1
                else:
                    right = int(math.floor(WINDOW_COLS / 2))

                top_left = img_integral[row - top, col - left, channel]
                top_right = img_integral[row - top, col + right, channel]
                bottom_left = img_integral[row + bottom, col - left, channel]
                bottom_right = img_integral[row + bottom, col + right, channel]

                div = ((top + bottom) * (left + right))

                img_final[row, col, channel] = (
                    (bottom_right + top_left) - (bottom_left + top_right)) / div

    return img_final

# ===============================================================================


def main():

    # Abre a imagem.
    # img = cv2.imread (INPUT_IMAGE, cv2.IMREAD_GRAYSCALE)
    img = cv2.imread(INPUT_IMAGE, cv2.IMREAD_COLOR)
    if img is None:
        print('Erro abrindo a imagem.\n')
        sys.exit()

    # É uma boa prática manter o shape com 3 valores, independente da imagem ser
    # colorida ou não. Também já convertemos para float32.
    img = img.reshape((img.shape[0], img.shape[1], img.shape[2]))
    img = img.astype(np.float32) / 255

    # Original
    cv2.imshow('00 - original', img)
    print('Imagem original')

    # Ingenuo:

    start_time = timeit.default_timer()
    img_ingenuo = ingenuo(img)
    cv2.imshow('01 - ingenuo', img_ingenuo)
    cv2.imwrite('01 - ingenuo.png', img*255)
    print('Tempo ingenuo: %f' % (timeit.default_timer() - start_time))

    # Separavel:

    start_time = timeit.default_timer()
    img_separavel = separavel(img)
    cv2.imshow('02 - separavel', img_separavel)
    cv2.imwrite('02 - separavel.png', img*255)
    print('Tempo separavel: %f' % (timeit.default_timer() - start_time))

    # Integral:

    start_time = timeit.default_timer()
    img_integral = integral(img)
    cv2.imshow('03 - integral', img_integral)
    cv2.imwrite('03 - integral.png', img*255)
    print('Tempo integral: %f' % (timeit.default_timer() - start_time))

    cv2.waitKey()
    cv2.destroyAllWindows()


if __name__ == '__main__':
    main()

# ===============================================================================

drive.mount('/content/drive')
